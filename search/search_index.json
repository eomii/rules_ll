{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>rules_ll</code>","text":"<p>An upstream Clang/LLVM-based toolchain for contemporary C++ and heterogeneous programming.</p> <p>This project interleaves Nix and Bazel with opinionated Starlark rules for C++. Purpose-built for the bleeding edge. Reproducible and hermetic beyond Bazel's dependency graph.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>Setup</li> <li>Examples</li> <li>Guides</li> </ul> <p>If you have questions about remote execution, consider asking for help in the NativeLink Slack.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of conduct","text":"<p><code>rules_ll</code> follows the LLVM code of conduct.</p> <p>Report violations to:</p> <ul> <li>Aaron Siddhartha Mondal, <code>aaron@eomii.org</code></li> <li>Jannis Marcel Fengler, <code>jannis@eomii.org</code></li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p><code>rules_ll</code> uses code-quality tools for a consistent style across the repository.</p>"},{"location":"CONTRIBUTING/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>Use the <code>rules_ll</code> development shell to get the various tools you need to work on the project:</p> (from within the rules_ll root directory)<pre><code>nix develop .#dev\n</code></pre> <p>The flake automatically sets up pre-commit in the shell which run on every local commit. You can also run the hooks manually:</p> (from within the rules_ll root directory)<pre><code>nix flake check -L\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-docs","title":"Building the docs","text":"<p><code>rules_ll</code> uses <code>mkdocs</code> for the docs. To run a local development server:</p> (from within the rules_ll root directory)<pre><code>mkdocs serve\n</code></pre> <p>If you change documentation in the <code>ll/</code> directory, regenerate the API reference docs:</p> (from within the rules_ll root directory)<pre><code>./generate_docs.sh\n</code></pre> <p>This populates the <code>docs/reference/</code> directory with the updated markdown files.</p>"},{"location":"CONTRIBUTING/#tests","title":"Tests","text":"<p>The examples at <code>rules_ll/examples</code> also act as tests for the project. If you don't use <code>devenv</code> make sure to run the examples from the flake in the <code>examples</code> directory:</p> (from within the rules_ll/examples directory)<pre><code>nix develop\n</code></pre> <p>Heterogeneous tests fail on machines without the corresponding GPU, but they should still produce executables:</p> (from within the rules_ll/examples directory)<pre><code># Should pass on all machines.\nbazel test cpp\n\n# Should pass on machines with supported Nvidia GPUs.\nbazel test nvptx\n\n# Should pass on machines with supported AMD GPUs.\nbazel test amdgpu\n\n# Even if some of these tests fail, they should all build and run.\nbazel test all\n</code></pre>"},{"location":"SECURITY/","title":"Security policy","text":"<p>By default, GitHub's bots crawl <code>rules_ll</code> for security vulnerabilities wherever possible.</p> <p>The <code>rules_ll</code> developers place a high emphasis on fixing any vulnerabilities, so please don't hesitate to send a report if something doesn't look right.</p>"},{"location":"SECURITY/#supported-versions","title":"Supported versions","text":"<p><code>rules_ll</code> always supports just the latest tag. Consider all older versions as unsupported and deprecated.</p>"},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a vulnerability","text":"<p>Please prefer reporting vulnerabilities via GitHub.</p> <p>If you prefer communication via email please contact aaron@eomii.org and jannis@eomii.org.</p>"},{"location":"SECURITY/#vulnerability-disclosure-and-advisories","title":"Vulnerability disclosure and advisories","text":"<p>See Advisories for publicly disclosed vulnerabilities.</p>"},{"location":"guides/","title":"Guides","text":"<p>These guides explain some more advanced features of <code>rules_ll</code>. If these guides don't explain a topic well, feel free to open an issue on GitHub.</p> <ul> <li>Clang-Tidy: How to set up a compilation database and use it   with Clang-Tidy.</li> <li>C++ Modules: How to write targets that use C++ modules.</li> <li>CUDA and HIP: How to build code that targets GPUs.</li> <li>External dependencies: How to add non-Bazel   dependencies to your build.</li> <li>Sanitizers: How to integrate sanitizers in your builds.</li> </ul>"},{"location":"guides/clang_tidy/","title":"Clang-tidy","text":"<p><code>rules_ll</code> includes a Bazel overlay for <code>clang-tidy</code>. The <code>ll_compilation_database</code> rule creates a compilation database for a target and its dependencies. Running that rule invokes <code>clang-tidy</code> on it.</p> <p>You can find similar examples to the ones in this guide at <code>rules_ll/examples/clang_tidy_example</code>.</p>"},{"location":"guides/clang_tidy/#usage","title":"Usage","text":"<p>For a target <code>my_library</code> defined in a <code>BUILD.bazel</code> file, add an <code>ll_compilation_database</code> like this:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_library\", \"ll_compilation_database\")\n\nfilegroup(\n   name = \"clang_tidy_config\",\n   srcs = [\".clang-tidy\"],\n)\n\nll_library(\n    name = \"my_library\",\n    srcs = [\"my_library.cpp\"],\n)\n\nll_compilation_database(\n    name = \"my_library_compile_commands\",\n    targets = [\":my_library\"],\n    config = \":clang_tidy_config\",\n)\n</code></pre> <p>The <code>targets</code> attribute in <code>ll_compilation_database</code> declares the targets included in the <code>compile_commands.json</code> file.</p> <p>The <code>.clang-tidy</code> file configures <code>clang-tidy</code>. See <code>rules_ll/examples/.clang-tidy</code> for an example.</p> <p>To run <code>clang-tidy</code> on the sources of <code>my_library_compile_commands</code>, run</p> <pre><code>bazel run my_library_compile_commands\n# Prints warnings for my_library.cpp.\n</code></pre> <p>If you require a <code>compile_commands.json</code> file for using it with an IDE, you can build instead of run the <code>compile_commands</code> target and locate the <code>compile_commands.json</code> file in the <code>bazel-bin</code> directory.</p> <pre><code>bazel build my_library_compile_commands\n# Output in bazel-bin/k8-fastbuild/bin\n</code></pre> <p>This builds a file named <code>compile_commands.json</code>, regardless of the <code>ll_compilation_database</code> target's <code>name</code> attribute.</p>"},{"location":"guides/clang_tidy/#compilation-databases","title":"Compilation databases","text":"<p>The <code>ll_compilation_database</code> rule constructs the <code>compile_commands.json</code> file from all targets needed to build the targets in the <code>targets</code> attribute. Consider the following targets:</p> BUILD.bazel<pre><code>filegroup(\n   name = \"clang_tidy_config\",\n   srcs = [\".clang-tidy\"],\n)\n\nll_library(\n    name = \"mylib_1\",\n    srcs = [\n        \"mylib_1.cpp\",\n        \"mylib_1_additional_source.cpp\",\n    ]\n)\n\nll_library(\n    name = \"mylib_2\",\n    srcs = \"mylib_2.cpp\",\n    deps = [\n        \":mylib_1\",\n    ]\n)\n\nll_compilation_database(\n    name = \"cdb_1\",\n    targets = [\":mylib_1\"],\n    config = \":clang_tidy_config\",\n)\n\nll_compilation_database(\n    name = \"cdb_2\",\n    targets = [\":mylib_2\"],\n    config = \":clang_tidy_config\",\n)\n\nll_compilation_database(\n   name = \"compile_commands\",\n   targets = [\n      \":mylib_1\",\n      \":mylib_2\",\n   ],\n   config = \":clang_tidy_config\",\n)\n</code></pre> <p>Running <code>cdb_1</code> invokes <code>clang-tidy</code> on <code>mylib_1.cpp</code> alone:</p> <pre><code>bazel run cdb_1\n# Prints warnings for mylib_1.cpp and mylib_1_additional_source.cpp.\n</code></pre> <p>Running <code>cdb_2</code> invokes <code>clang-tidy</code> on <code>mylib_1.cpp</code> and <code>mylib_2.cpp</code>:</p> <pre><code>bazel run cdb_2\n# Prints warnings for mylib_1.cpp, mylib_2.cpp and\n# mylib_1_additional_source.cpp.\n</code></pre> <p>Running <code>compile_commands</code> also invokes <code>clang-tidy</code> on both targets.</p>"},{"location":"guides/clang_tidy/#limitations","title":"Limitations","text":"<p>The <code>ll_compilation_database</code> rule doesn't support the <code>-fix</code> option for <code>clang-tidy</code>. The auto fixer tends to break code and would have to work outside of the Bazel build directories.</p>"},{"location":"guides/cuda_and_hip/","title":"CUDA and HIP","text":"<p><code>rules_ll</code> fully automates the setups for heterogeneous toolchains. This lets you build CUDA and HIP code with minimal adjustments to your build files.</p> <p>At the moment <code>rules_ll</code> supports Nvidia and AMD GPUs.</p> <p>You can find examples at <code>rules_ll/examples</code>.</p> <p>Warning</p> <p>This feature is still under heavy development. APIs will frequently change.</p>"},{"location":"guides/cuda_and_hip/#prerequisites","title":"Prerequisites","text":"<p>You do not need to install the CUDA Toolkit or the ROCm stack to use the heterogeneous toolchains - <code>rules_ll</code> does that for you. You do need to install an Nvidia or AMD driver on the system that runs the executables though. Since <code>rules_ll</code> bumps versions rather aggressively make sure to use the latest drivers.</p> <p>You don't need a GPU on the machine that builds the heterogeneous targets.</p>"},{"location":"guides/cuda_and_hip/#example","title":"Example","text":"<p>Heterogeneous targets need to know about three things:</p> <ol> <li>The framework that you used to write your code. At the moment you can use    CUDA and HIP. OpenMP and SYCL planned for future releases.</li> <li>The GPU target architecture. At the moment, <code>rules_ll</code> supports <code>nvptx</code> for    Nvidia GPUs and <code>amdgpu</code> for AMD GPUs. <code>spirv</code> for Intel GPUs planned for    future releases.</li> <li>The offload architectures of the target GPU models. Also known as compute    capability. You can find a list of Nvidia GPU models and corresponding    compute capabilities here and a    list of AMD GPU models and corresponding compute capabilities here.</li> </ol> <p>The <code>ll_library</code> and <code>ll_binary</code> rules have a <code>compilation_mode</code> attribute which you can set according to the scheme <code>&lt;framework&gt;_&lt;target_arch&gt;</code>:</p> Framework Target Architecture <code>compilation_mode</code> CUDA NVPTX <code>cuda_nvptx</code> HIP NVPTX <code>hip_nvptx</code> HIP AMDGPU <code>hip_amdgpu</code> <p>To offload to specific architectures, add the corresponding architecture to <code>compile_flags</code> with the <code>--offload-arch</code> flag.</p> Target Architecture Supported <code>offload-arch</code> Example <code>compile_flags</code> NVPTX 5.2 to 9.0 <code>--offload-arch=sm_52</code> AMDGPU GFX8 to GFX11 <code>--offload-arch=gfx1103</code> <p>For instance, to build HIP code for an Nvidia Titan V with compute capability 7.0 you could write a target like this:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n\nll_binary(\n   name = \"my_hip_nvptx_target\",\n   srcs = [\"main.cpp\"],\n   compilation_mode = \"hip_nvptx\",\n   compile_flags = [\n      \"--offload-arch=sm_70\",\n   ],\n)\n</code></pre> <p>For an AMD RX 7900 XT with compute capability GFX11 you could write a target like this:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n\nll_binary(\n    name = \"my_hip_amdgpu_target\",\n    srcs = [\"main.cpp\"],\n    compilation_mode = \"hip_amdgpu\",\n    compile_flags = [\n        \"--offload-arch=gfx1100\",\n    ],\n)\n</code></pre>"},{"location":"guides/cuda_and_hip/#targeting-all-available-architectures","title":"Targeting all available architectures","text":"<p>Use the <code>OFFLOAD_ALL_NVPTX</code> shortcut to target all supported NVPTX offload architectures:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"OFFLOAD_ALL_NVPTX\", \"ll_binary\")\n\nll_binary(\n   name = \"my_hip_nvptx_target\",\n   srcs = [\"main.cpp\"],\n   compilation_mode = \"hip_nvptx\",\n   compile_flags = OFFLOAD_ALL_NVPTX,\n)\n</code></pre> <p>Use the <code>OFFLOAD_ALL_AMDGPU</code> shortcut to target all supported AMDGPU offload architectures:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"OFFLOAD_ALL_AMDGPU\", \"ll_binary\")\n\nll_binary(\n   name = \"my_hip_amdgpu_target\",\n   srcs = [\"main.cpp\"],\n   compilation_mode = \"hip_amdgpu\",\n   compile_flags = OFFLOAD_ALL_AMDGPU,\n)\n</code></pre>"},{"location":"guides/cuda_and_hip/#relocatable-device-code","title":"Relocatable device code","text":"<p>To build relocatable device code, add <code>-fgpu-rdc</code> to <code>compile_flags</code>. This lets you split device code into different files for a cleaner repository layout. Note that this comes at the cost of an often negligible runtime performance penalty:</p> BUILD.bazel<pre><code>ll_library(\n   name = \"my_device_code\",\n   srcs = [\"device_code.cpp\"],\n   exposed_hdrs = [\"device_code_declaration.hpp\"],\n   compilation_mode = \"hip_nvptx\",\n   compile_flags = [\n      \"--offload-arch=sm_70\",\n      \"-fgpu-rdc\",\n   ],\n)\n\nll_binary(\n   name = \"my_hip_nvidia_target\",\n   srcs = [\"main.cpp\"],\n   compilation_mode = \"hip_nvptx\",\n   compile_flags = [\n      \"--offload-arch=sm_70\",\n      \"-fgpu-rdc\",\n   ],\n   deps = [\n      \":my_device_code\",\n   ],\n)\n</code></pre>"},{"location":"guides/cuda_and_hip/#caveats","title":"Caveats","text":"<p>C++ modules don't work with heterogeneous code yet.</p> <p>Targeting both NVPTX and AMDGPU in a single codebase requires separate targets, making build files somewhat verbose. <code>rules_ll</code> plans to change the API for heterogeneous compilation to use platforms so that <code>select</code> becomes viable for such use cases.</p> <p>Confusingly, the <code>compilation_mode</code> flag in <code>ll_*</code> targets has the name as the unrelated <code>--compilation_mode</code> flag for Bazel. Planned to change in the future.</p>"},{"location":"guides/external_dependencies/","title":"External dependencies","text":"<p>You can make dependencies from the Nix package repository available to <code>ll_*</code> targets in a hermetic, reproducible manner.</p>"},{"location":"guides/external_dependencies/#a-word-of-caution","title":"A word of caution","text":"<p>The external dependency mechanism in <code>rules_ll</code> lets you import external dependencies, but it globally affects all <code>ll_*</code> compile commands.</p> <p>Any change to an external dependency invalidates all caches and causes a full rebuild of all toolchains.</p>"},{"location":"guides/external_dependencies/#example","title":"Example","text":"<p>The <code>rules_ll</code> flake-parts module exposes an <code>actionEnv</code> attribute which you can use to set custom Bazel <code>--action-env</code> attributes in your generated <code>.bazelrc.ll</code>. Technically you can use the <code>.bazelrc.ll</code> generation logic to generate arbitrary <code>.bazelrc.*</code> fragments. If you intend to use it with <code>rules_ll</code>s Bazel toolchains you should use the <code>rules_ll.lib.action-env</code> function which lets you specify <code>LL_CFLAGS</code> and <code>LL_LDFLAGS</code> and handles all other environment variables automatically.</p> <p>Since <code>rules_ll</code> uses the <code>clang-linker-wrapper</code> as its linking tool you don't need to add <code>-Wl,...</code> to flags in <code>LL_LDFLAGS</code>.</p> <p>Don't use spaces in these flags and separate different flags with colons.</p> Static linkageDynamic linkage flake.nix<pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n    flake-parts = {\n      url = \"github:hercules-ci/flake-parts\";\n      inputs.nixpkgs-lib.follows = \"nixpkgs\";\n    };\n    rules_ll = {\n      # If you use this file as template, substitute the line below with this,\n      # where `&lt;version&gt;` is the version of rules_ll you want to use:\n      #\n      #   rules_ll.url = \"github:eomii/rules_ll/&lt;version&gt;\";\n      url = \"github:eomii/rules_ll\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n      inputs.flake-parts.follows = \"flake-parts\";\n    };\n  };\n  outputs =\n    { self\n    , rules_ll\n    , flake-parts\n    , ...\n    } @ inputs:\n    flake-parts.lib.mkFlake { inherit inputs; }\n      {\n        systems = [\n          \"x86_64-linux\"\n        ];\n        imports = [\n          inputs.rules_ll.flakeModule\n        ];\n        perSystem =\n          { config\n          , pkgs\n          , system\n          , lib\n          , ...\n          }:\n          let\n            openssl = (pkgs.openssl.override { static = true; });\n          in\n          {\n            rules_ll.settings.actionEnv = rules_ll.lib.action-env {\n              inherit pkgs;\n              LL_CFLAGS = \"-I${openssl.dev}/include\";\n              LL_LDFLAGS = \"-L${openssl.out}/lib\";\n            };\n            devShells.default = pkgs.mkShell {\n              nativeBuildInputs = [ pkgs.bazel_7 ];\n              shellHook = ''\n                # Generate .bazelrc.ll which containes action-env\n                # configuration when rules_ll is run from a nix environment.\n                ${config.rules_ll.installationScript}\n\n                # Prevent rules_cc from using anything other than clang.\n                export CC=clang\n\n                # Probably a bug in nix. Setting LD=ld.lld here won't work.\n                export LD=${pkgs.llvmPackages_17.lld}/bin/ld.lld\n\n                # Java needs to be the same version as in the Bazel wrapper.\n                export JAVA_HOME=${pkgs.jdk17_headless}/lib/openjdk\n              '';\n            };\n          };\n      };\n</code></pre> flake.nix<pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n    flake-parts = {\n      url = \"github:hercules-ci/flake-parts\";\n      inputs.nixpkgs-lib.follows = \"nixpkgs\";\n    };\n    rules_ll = {\n      # If you use this file as template, substitute the line below with this,\n      # where `&lt;version&gt;` is the version of rules_ll you want to use:\n      #\n      #   rules_ll.url = \"github:eomii/rules_ll/&lt;version&gt;\";\n      url = \"github:eomii/rules_ll\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n      inputs.flake-parts.follows = \"flake-parts\";\n    };\n  };\n  outputs =\n    { self\n    , rules_ll\n    , flake-parts\n    , ...\n    } @ inputs:\n    flake-parts.lib.mkFlake { inherit inputs; }\n      {\n        systems = [\n          \"x86_64-linux\"\n        ];\n        imports = [\n          inputs.rules_ll.flakeModule\n        ];\n        perSystem =\n          { config\n          , pkgs\n          , system\n          , lib\n          , ...\n          }:\n          {\n            rules_ll.settings.actionEnv = rules_ll.lib.action-env {\n              inherit pkgs;\n              LL_CFLAGS = \"-I${pkgs.openssl.dev}/include\";\n              LL_LDFLAGS = \"-L${pkgs.openssl.out}/lib:-rpath=${pkgs.openssl.out}/lib\";\n            };\n            devShells.default = pkgs.mkShell {\n              nativeBuildInputs = [ pkgs.bazel_7 ];\n              shellHook = ''\n                # Generate .bazelrc.ll which containes action-env\n                # configuration when rules_ll is run from a nix environment.\n                ${config.rules_ll.installationScript}\n\n                # Prevent rules_cc from using anything other than clang.\n                export CC=clang\n\n                # Probably a bug in nix. Setting LD=ld.lld here won't work.\n                export LD=${pkgs.llvmPackages_17.lld}/bin/ld.lld\n\n                # Java needs to be the same version as in the Bazel wrapper.\n                export JAVA_HOME=${pkgs.jdk17_headless}/lib/openjdk\n              '';\n            };\n          };\n      };\n</code></pre> <p>You can see the values of <code>LL_CFLAGS</code> and <code>LL_LDFLAGS</code> in the generated <code>.bazelrc.ll</code>:</p> Static linkageDynamic linkage <pre><code>cat .bazelrc.ll $LL_CFLAGS\n# ...\n#\n# build --action_env=LL_CFLAGS=-I/nix/store/&lt;...&gt;-openssl-&lt;version&gt;-dev/include\n# build --action_env=LL_LDFLAGS=-L/nix/store/&lt;...&gt;-openssl-&lt;version&gt;/lib\n</code></pre> <pre><code># ...\n#\n# build --action_env=LL_CFLAGS=-I/nix/store/&lt;...&gt;-openssl-&lt;version&gt;-dev/include\n# build --action_env=LL_LDFLAGS=-L/nix/store/&lt;...&gt;-openssl-&lt;version&gt;/lib:-rpath=/nix/store/&lt;...&gt;-openssl-&lt;version&gt;/lib\n</code></pre> <p>You can now add the library via <code>link_flags</code> or <code>shared_object_link_flags</code>:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n\nll_binary(\n    name = \"my_externally_dependent_executable\",\n    srcs = [\"main.cpp\"],\n    link_flags = [\n        \"-lcrypto\",  # Default linkage as set in the flake.\n        # \"-l:libcrypto.a\",  # Explicit static linkage.\n        # \"-l:libcrypto.so\",  # Explicit dynamic linkage.\n    ],\n)\n</code></pre> <p>Keep in mind that <code>LL_CFLAGS</code> and <code>LL_LDFLAGS</code> globally affect <code>ll_*</code> targets:</p> <ul> <li>Every compile action can see all headers in <code>LL_CFLAGS</code>. If two dependencies   contain headers with the same name your builds might break with confusing   errors. If you suspect a wrong header inclusion you can add <code>-H</code> to the   <code>compile_flags</code> attribute of your target to print the full inclusion chain.</li> <li>It's possible to reference paths to non-nix dependencies in these flags, but   doing so breaks the hermeticity and reproducibility of the build.</li> <li>Referencing paths that contain headers supplied by <code>rules_ll</code> itself such as   <code>/usr/include</code> or <code>${pkgs.libcxx}/include</code> overrides parts of the internal   <code>ll_*</code> toolchains and breaks all <code>ll_*</code> targets.</li> <li>Link actions add all <code>-rpath</code> values from <code>LL_LDFLAGS</code> to every target even if   the target doesn't actually link the corresponding library. This affects   <code>ll_binary</code>, <code>ll_test</code> and <code>ll_library</code> with <code>emit = [\"shared_object\"]</code>.</li> </ul>"},{"location":"guides/modules/","title":"C++ modules","text":"<p>Apart from clean dependency management, modules can reduce compile times. Try to use them if you can.</p> <p>You can find full examples at <code>rules_ll/examples</code>.</p> <p>Note</p> <p><code>rules_ll</code> has no builtin support for Clang modules. This feature precedes C++ modules.</p> <p>You can't use standard library headers via <code>import std.iostream;</code> as you would when using Clang modules.</p> <p>Due to a bug in <code>clang-tidy</code> you have to silence <code>readability-redundant-declaration</code> when using modules.</p> <p>Warning</p> <p>As modules stabilize upstream, expect this API to change in the future.</p>"},{"location":"guides/modules/#basic-usage","title":"Basic usage","text":"<p>Consider the following module without implementation:</p> hello.cppm<pre><code>module;\n\n#include &lt;iostream&gt;\n\nexport module hello;\n\nexport namespace hello {\n\nauto say_hello() -&gt; void {\n   std::cout &lt;&lt; \"Hello from hello interface!\" &lt;&lt; std::endl;\n}\n\n} // namespace hello\n</code></pre> main.cpp<pre><code>import hello;\n\nauto main() -&gt; int {\n   hello::say_hello();\n   return 0;\n}\n</code></pre> <p>The <code>rules_ll</code> build file for this could look like this:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n\nll_binary(\n   name = \"mybinary\",\n   srcs = [\"main.cpp\"],\n   interfaces = {\"hello.cppm\": \"hello\"},\n   compile_flags = [\"-std=c++20\"],\n)\n</code></pre> <p>The <code>interfaces</code> attribute <code>dict</code> maps module interfaces to module names.</p>"},{"location":"guides/modules/#interface-implementation-split","title":"Interface-implementation split","text":"<p>Clang expects interfaces to end in <code>.cppm</code>:</p> hello.cpp<pre><code>module;\n\n#include &lt;iostream&gt;\n\nmodule hello;\n\nnamespace hello {\n\nauto say_hello_from_implementaion() -&gt; void {\n   std::cout &lt;&lt; \"Hello from implementation!\" &lt;&lt; std::endl;\n}\n\n} // namespace hello\n</code></pre> hello.cppm<pre><code>module;\n\n#include &lt;iostream&gt;\n\nexport module hello;\n\nexport namespace hello {\n\nauto say_hello_from_implementation() -&gt; void;\nauto say_hello_from_interface() -&gt; void {\n    std::cout &lt;&lt; \"Hello from interface!\" &lt;&lt; std::endl;\n}\n\n}\n</code></pre> main.cpp<pre><code>import hello;\n\nauto main() -&gt; int {\n   hello::say_hello_from_implementation();\n   hello::say_hello_from_interface();\n   return 0;\n}\n</code></pre> <p>To build this module, your build file could look like this:</p> BUILD.bazel<pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_library\", \"ll_binary\")\n\nll_library(\n   name = \"hello\",\n   srcs = [\"hello.cpp\"],\n   exposed_interfaces = {\"hello.cppm\": \"hello\"},\n   compile_flags = [\"-std=c++20\"],\n)\n\nll_binary(\n   name = \"main\",\n   srcs = [\"main.cpp\"],\n   deps = [\":hello\"],\n)\n</code></pre> <p>Use <code>exposed_interfaces</code> in <code>ll_library</code>. This way the <code>main</code> target can see the interface for the <code>hello</code> module.</p>"},{"location":"guides/modules/#under-the-hood","title":"Under the hood","text":"<p>For the preceding example, <code>rules_ll</code> builds <code>main</code> as follows:</p> <p></p> <p>For the <code>ll_library</code> target:</p> <ul> <li>The compiler precompiles <code>hello.cppm</code> to <code>hello.pcm</code>.</li> <li>The compiler compiles <code>hello.pcm</code> to <code>hello.interface.o</code>. The <code>.interface</code>   part avoids name clashes with outputs from files like <code>hello.cpp</code>.</li> <li>The compiler compiles <code>hello.cpp</code> to <code>hello.o</code> using <code>hello.pcm</code>.</li> <li>By default <code>ll_library</code> archives <code>hello.interface.o</code> and <code>hello.o</code> to   <code>hello.a</code>.  The <code>name</code> attribute determines the filename. The archive name   doesn't depend on the module name. You can change this behavior with the   <code>emit</code> attribute.</li> </ul> <p>For the <code>ll_binary</code> target:</p> <ul> <li>The compiler compiles <code>main.cpp</code> to <code>main.o</code> using <code>hello.pcm</code>. This step   doesn't depend on <code>hello.o</code>.</li> <li>The linker links <code>hello.a</code> and <code>main.o</code> to the final executable <code>main</code>.</li> </ul>"},{"location":"guides/modules/#pitfalls","title":"Pitfalls","text":"<p>The <code>exposed</code> attribute applies to all interfaces in <code>ll_library</code>, including those in the <code>interfaces</code> attribute. <code>rules_ll</code> builds <code>interfaces</code> first and then makes them visible to <code>exposed_interfaces</code>. This way you can declare more complex modules in a single target.</p> <p>If you have a dependency chain <code>a -&gt; b -&gt; c</code> and you <code>import c</code> in a target, you need to add <code>deps = [\":a\", \":b\", \":c\"]</code> to that target. The build still requires the interfaces for <code>a</code> and <code>b</code>, even though you didn't explicitly specify those in your code.</p>"},{"location":"guides/modules/#suggestions","title":"Suggestions","text":"<p>Read the C++ standard on modules.</p> <p>Read about Standard C++ Modules in Clang.</p> <p>Name your modules according to this proposal. Use lower-case ASCII characters with <code>&lt;organization&gt;.&lt;project&gt;.&lt;module_name&gt;</code> as naming scheme.</p> <p>Use namespaces that mimic your module names. This way you can use a symbol <code>f</code> in module <code>eomii.someproject</code> as <code>eomii::someproject::f</code>.</p> <p>Use module partitions to keep namespace hierarchies flat.</p> <p>Use a file layout that reflects your module hierarchies.</p>"},{"location":"guides/modules/#current-state-of-usability","title":"Current state of usability","text":"<p>The module support in <code>rules_ll</code> conforms to the standard, but doesn't include support for header units. Use <code>#include &lt;iostream&gt;</code> in global module fragments instead of <code>import &lt;iostream&gt;;</code>.</p> <p>Clang has unstable, experimental module support. To fix current compiler bugs, <code>rules_ll</code> applies custom patches to <code>libcxx</code>.</p> <p><code>rules_ll</code> adjusts compilation databases emitted by <code>ll_compilation_database</code>. This makes modules work with <code>clang-tidy</code>.</p>"},{"location":"guides/sanitizers/","title":"Sanitizers","text":"<p>Sanitizers can improve the robustness of your code.</p> <p>Full examples at <code>rules_ll/examples/sanitizers</code>.</p>"},{"location":"guides/sanitizers/#primer","title":"Primer","text":"<p>Lots of code-quality tools rely on static analysis. A static analyzer like Clang-Tidy reports errors during compile time. This can prevent lots of issues, but sometimes a bug might slip through the cracks of static analysis.</p> <p>Sanitizers enable dynamic analysis. They report issues during runtime. Sanitizers instrument your builds. This means that they instruct Clang to add instrumentation code around regions of interest. This changes the effective runtime behavior of your targets. For instance, a memory sanitizer might add checks and logging around memory access.</p> <p>The added instrumentation code can incur heavy performance penalties.</p>"},{"location":"guides/sanitizers/#available-sanitizers","title":"Available sanitizers","text":"<p>You can enable each sanitizer with the <code>sanitize</code> attribute in <code>ll_*</code> targets:</p> BUILD.bazel<pre><code>ll_binary(\n   name = \"mytarget\"\n   srcs = [\"main.cpp\"],\n   sanitize = [\"address\"],\n)\n</code></pre> <p>At the moment, <code>rules_ll</code> supports these values for <code>sanitize</code>:</p> <code>\"address\"</code> <p>Use AddressSanitizer, to detect memory errors. Slowdown of ~2x. Run targets that invoke CUDA-based kernels, with <code>ASAN_OPTIONS=protect_shadow_gap=0</code>.</p> <code>\"leak\"</code> <p>Use LeakSanitizer to detect memory leaks. Already part of AddressSanitizer. Use LeakSanitizer if you want to use it in standalone mode. Almost no runtime overhead until the end of the process where it detects leaks.</p> <code>\"memory\"</code> <p>Use MemorySanitizer to detect uninitialized reads. Slowdown of ~3x. Add <code>\"-fsanitize-memory-track-origins=2\"</code> to <code>compile_flags</code> to track the origins of uninitialized values.</p> <code>\"undefined_behavior\"</code> <p>Use UndefinedBehaviorSanitizer to detect undefined behavior. Small runtime overhead.</p> <code>\"thread\"</code> <p>Use ThreadSanitizer to detect data races. Slowdown of ~5x-15x. Memory overhead of ~5x-10x.</p> <p>You can combine some of these, but most of them don't play well together. If possible, use just one at a time.</p> <p>Since sanitizers detect issues during runtime, they don't yield reproducible error reports. Run sanitized targets several times and build them with different optimization levels to maximize coverage.</p>"},{"location":"guides/sanitizers/#example","title":"Example","text":"<p>This code has a silent use-after-free bug:</p> main.cpp<pre><code>int main(int argc, char **argv) {\n  int *array = new int[100];\n  delete[] array;\n  return array[argc];  // Bad.\n}\n</code></pre> BUILD.bazel<pre><code>ll_binary(\n   name = \"bug\"\n   srcs = [\"main.cpp\"],\n)\n</code></pre> <pre><code>bazel run bug\n# Appears to run fine.\n</code></pre> <p>To verify that the code works as intended, add AddressSanitizer instrumentation to the target:</p> BUILD.bazel<pre><code>ll_binary(\n    name = \"bug\",\n    srcs = [\"main.cpp\"],\n    sanitize = [\"address\"],\n)\n</code></pre> <p>The sanitizer reports a <code>heap-use-after-free</code> bug and where it occurred:</p> <pre><code>bazel run bug\n</code></pre> <pre><code>=================================================================\n==220498==ERROR: AddressSanitizer: heap-use-after-free on address\n  0x614000000048 at pc 0x5645a5c68118 bp 0x7ffe69c17f40 sp 0x7ffe69c17f20\n\nREAD of size 4 at 0x614000000048 thread T0\n    #0 0x5645a5c68117 in main main.cpp:4:10\n    #1 0x7efdaa1f32c9  (/usr/lib64/libc.so.6+0x232c9)\n    #2 0x7efdaa1f3384 in __libc_start_main (/usr/lib64/libc.so.6+0x23384)\n    #3 0x5645a5b23610 in _start (bug+0x6e610)\n\n0x614000000048 is located 8 bytes inside of 400-byte region\n  [0x614000000040,0x6140000001d0)\n\nfreed by thread T0 here:\n    #0 0x5645a5c64e18 in operator delete[](void*) (bug+0x1afe18)\n    #1 0x5645a5c680cc in main main.cpp:3:3\n    #2 0x7efdaa1f32c9  (/usr/lib64/libc.so.6+0x232c9)\n\npreviously allocated by thread T0 here:\n    #0 0x5645a5c6447c in operator new[](unsigned long) (bug+0x1af47c)\n    #1 0x5645a5c680ad in main main.cpp:2:16\n    #2 0x7efdaa1f32c9  (/usr/lib64/libc.so.6+0x232c9)\n\nSUMMARY: AddressSanitizer: heap-use-after-free main.cpp:4:10 in main\nShadow bytes around the buggy address:\n  0x613ffffffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x613ffffffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x613ffffffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x613fffffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x613fffffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=&gt;0x614000000000: fa fa fa fa fa fa fa fa fd[fd]fd fd fd fd fd fd\n  0x614000000080: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x614000000100: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x614000000180: fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa fa\n  0x614000000200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x614000000280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07\n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==220498==ABORTING\n</code></pre>"},{"location":"guides/sanitizers/#usage-in-build-files","title":"Usage in build files","text":"<p>To toggle between test and release builds you can add command line flags to your builds.</p> <p>This <code>string_flag</code> and <code>config_setting</code> let you add your sanitizer of choice on the command line:</p> myproject/BUILD.bazel<pre><code>SANITIZERS = [\n    \"address\",\n    \"leak\",\n    \"memory\",\n    \"none\",\n    \"thread\",\n    \"undefined_behavior\",\n]\n\nstring_flag(\n    name = \"sanitize\",\n    build_setting_default = \"none\",\n    values = SANITIZERS,\n)\n\n[\n    config_setting(\n        name = sanitizer,\n        flag_values = {\":sanitize\": sanitizer},\n    )\n    for sanitizer in SANITIZERS\n]\n\nMYPROJECT_SANITIZE = select({\n    sanitizer: [sanitizer]\n    for sanitizer in SANITIZERS\n})\n</code></pre> <p>You can now add the <code>MYPROJECT_SANITIZE</code> selector to <code>ll_*</code> targets. The <code>--//myproject:sanitize=&lt;sanitizer_value&gt;</code> flag then lets you enable each sanitizer:</p> BUILD.bazel<pre><code>ll_library(\n   name = \"mylib\",\n   srcs = [\"mylib.cpp\"],\n   exposed_hdrs = [\"mylib_public_api.hpp\"],\n   sanitize = MYPROJECT_SANITIZE,\n)\n\nll_binary(\n   name = \"myproject\",\n   srcs = [\"main.cpp\"],\n   deps = [\":mylib\"],\n   sanitize = MYPROJECT_SANITIZE,\n)\n</code></pre> <pre><code>bazel run --//myproject:sanitize=address myproject\n# Builds with address sanitizer and runs the executable.\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Built from the <code>.bzl</code> sources with Stardoc.</p> <ul> <li>//ll:actions</li> <li>//ll:args</li> <li>//ll:attributes</li> <li>//ll:compilation_database</li> <li>//ll:coverage</li> <li>//ll:defs</li> <li>//ll:driver</li> <li>//ll:environment</li> <li>//ll:inputs</li> <li>//ll:ll</li> <li>//ll:llvm_project_deps</li> <li>//ll:outputs</li> <li>//ll:providers</li> <li>//ll:resolve_rule_inputs</li> <li>//ll:toolchain</li> <li>//ll:tools</li> <li>//ll:transitions</li> </ul>"},{"location":"reference/actions/","title":"<code>//ll:actions.bzl</code>","text":"<p>Actions wiring up inputs, outputs, and tools to emit output files.</p> <p>Every function in this file wraps <code>ctx.actions.run</code> or <code>ctx.actions.run_shell</code>.</p> <p></p>"},{"location":"reference/actions/#compile_object","title":"<code>compile_object</code>","text":"<pre><code>compile_object(ctx, in_file, headers, defines, includes, angled_includes, bmis)</code></pre> <p>Create a compiled object.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> The input file to compile. <code>headers</code> A <code>depset</code> of files made available to the compile action. <code>defines</code> A <code>depset</code> of defines passed to the compile action. <code>includes</code> A <code>depset</code> of includes passed to the compile action. <code>angled_includes</code> A <code>depset</code> of angled includes passed to the compile action. <code>bmis</code> A <code>depset</code> of tuples <code>(interface, name)</code>, each consisting of a binary module interface <code>interface</code> and a module name <code>name</code>. <p><code>returns</code></p> <p>A tuple <code>(out_file, cdf)</code>, of an output file and a compilation database   fragment.</p> <p></p>"},{"location":"reference/actions/#compile_objects","title":"<code>compile_objects</code>","text":"<pre><code>compile_objects(ctx, headers, defines, includes, angled_includes, bmis, internal_bmis)</code></pre> <p>Create compiled objects emitted by the rule.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>headers</code> A <code>depset</code> of files made available to compile actions. <code>defines</code> A <code>depset</code> of defines passed to compile actions. <code>includes</code> A <code>depset</code> of includes passed to compile actions. <code>angled_includes</code> A <code>depset</code> of angled includes passed to compile actions. <code>bmis</code> A <code>depset</code> of tuples <code>(interface, name)</code>, each consisting of a binary module interface <code>interface</code> and a module name <code>name</code>. <code>internal_bmis</code> Like <code>bmis</code>, but can't see the files in <code>bmis</code> during compilation. <p><code>returns</code></p> <p>A tuple <code>(out_files, cdfs)</code>, of output files and compilation database   fragments.</p> <p></p>"},{"location":"reference/actions/#create_archive_library","title":"<code>create_archive_library</code>","text":"<pre><code>create_archive_library(ctx, in_files)</code></pre> <p>Create an archive action for an archive.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A <code>depset</code> of input files. <p><code>returns</code></p> <p>An output file.</p> <p></p>"},{"location":"reference/actions/#link_executable","title":"<code>link_executable</code>","text":"<pre><code>link_executable(ctx, in_files)</code></pre> <p>Create a link action for an executable.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A <code>depset</code> of input files. <p><code>returns</code></p> <p>An output file.</p> <p></p>"},{"location":"reference/actions/#link_shared_object","title":"<code>link_shared_object</code>","text":"<pre><code>link_shared_object(ctx, in_files)</code></pre> <p>Create a link action for a shared object.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A <code>depset</code> of input files. <p><code>returns</code></p> <p>An output file.</p> <p></p>"},{"location":"reference/actions/#precompile_interface","title":"<code>precompile_interface</code>","text":"<pre><code>precompile_interface(ctx, in_file, headers, defines, includes, angled_includes, bmis)</code></pre> <p><code>parameters</code></p> Name Description <code>ctx</code> <code>in_file</code> <code>headers</code> <code>defines</code> <code>includes</code> <code>angled_includes</code> <code>bmis</code> <p></p>"},{"location":"reference/actions/#precompile_interfaces","title":"<code>precompile_interfaces</code>","text":"<pre><code>precompile_interfaces(ctx, headers, defines, includes, angled_includes, bmis, precompile_exposed)</code></pre> <p>Create precompiled module interfaces.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>headers</code> A <code>depset</code> of files made available to compile actions. <code>defines</code> A <code>depset</code> of defines passed to compile actions. <code>includes</code> A <code>depset</code> of includes passed to compile actions. <code>angled_includes</code> A <code>depset</code> of angled includes passed to compile actions. <code>bmis</code> A <code>depset</code> of tuples <code>(interface, name)</code>, each consisting of a binary module interface <code>interface</code> and a module name <code>name</code>. <code>precompile_exposed</code> A <code>boolean</code> indicating whether to precompile exposed BMIs. Set to <code>True</code> for libraries and to <code>False</code> for binaries. <p><code>returns</code></p> <p>A tuple <code>(internal_bmis, exposed_bmis, cdfs)</code>.</p>"},{"location":"reference/args/","title":"<code>//ll:args.bzl</code>","text":"<p>The functions that create <code>Args</code> for use in rule actions.</p> <p></p>"},{"location":"reference/args/#compile_object_args","title":"<code>compile_object_args</code>","text":"<pre><code>compile_object_args(ctx, in_file, out_file, cdf, defines, includes, angled_includes, bmis)</code></pre> <p>Construct <code>Args</code> for compile actions.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> The input file to compile. <code>out_file</code> The output file. <code>cdf</code> A file to store the compilation database fragment. <code>defines</code> A <code>depset</code> of defines for the target. Added with <code>-D</code>. <code>includes</code> A <code>depset</code> of includes for the target. Added with <code>-iquote</code>. <code>angled_includes</code> A <code>depset</code> of angled includes for the target. Added with <code>-I</code>. <code>bmis</code> A <code>depset</code> of tuples <code>(interface, name)</code>, each consisting of a binary module interface <code>interface</code> and a module name <code>name</code>. Added in a scheme resembling <code>-fmodule-file=name=interface</code>. <p><code>returns</code></p> <p>An <code>Args</code> object.</p> <p></p>"},{"location":"reference/args/#create_archive_library_args","title":"<code>create_archive_library_args</code>","text":"<pre><code>create_archive_library_args(ctx, in_files, out_file)</code></pre> <p>Construct <code>Args</code> for archive actions.</p> <p>Uses <code>-cqL</code> for regular archiving and <code>-vqL</code> for debug builds.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A <code>depset</code> of input files. <code>out_file</code> The output file. <p><code>returns</code></p> <p>An <code>Args</code> object.</p> <p></p>"},{"location":"reference/args/#link_executable_args","title":"<code>link_executable_args</code>","text":"<pre><code>link_executable_args(ctx, in_files, out_file, mode)</code></pre> <p>Construct <code>Args</code> for link actions.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A <code>depset</code> of input files. <code>out_file</code> The output file. <code>mode</code> Either <code>\"executable\"</code> or <code>\"shared_object\"</code>, depending on the desired output type. <p><code>returns</code></p> <p>An <code>Args</code> object.</p> <p></p>"},{"location":"reference/args/#llvm_bindir_path","title":"<code>llvm_bindir_path</code>","text":"<pre><code>llvm_bindir_path(ctx)</code></pre> <p><code>parameters</code></p> Name Description <code>ctx</code>"},{"location":"reference/attributes/","title":"<code>//ll:attributes.bzl</code>","text":"<p>Attributes used by the <code>ll_toolchain</code>, <code>ll_library</code> and <code>ll_binary</code> rules.</p>"},{"location":"reference/compilation_database/","title":"<code>//ll:compilation_database.bzl</code>","text":"<p>Implements the <code>ll_compilation_database</code> rule.</p> <p></p>"},{"location":"reference/compilation_database/#ll_compilation_database","title":"<code>ll_compilation_database</code>","text":"<pre><code>ll_compilation_database(name, config, exclude, targets)</code></pre> <p>Executable target for building a compilation database and running clang-tidy on it.</p> <p>For a full guide see Clang-Tidy.</p> <p>See <code>rules_ll/examples</code> for examples. <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>config</code> <code>Label</code>, required. The label of a <code>.clang-tidy</code> configuration file. <code>exclude</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exclude all targets whose path includes one at least one of the provided strings. <code>targets</code> <code>List of labels</code>, required. The labels added to the compilation database."},{"location":"reference/coverage/","title":"<code>//ll:coverage.bzl</code>","text":"<p>Implements the <code>ll_coverage_test</code> rule.</p> <p></p>"},{"location":"reference/coverage/#ll_coverage_test","title":"<code>ll_coverage_test</code>","text":"<pre><code>ll_coverage_test(name, target)</code></pre> <p>TODO <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>target</code> <code>Label</code>, required. The executable to run and collect coverage data from."},{"location":"reference/defs/","title":"<code>//ll:defs.bzl</code>","text":"<p>Import these rules in your <code>BUILD.bazel</code> files.</p> <p>To load for example the <code>ll_binary</code> rule:</p> <pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n</code></pre> <p></p>"},{"location":"reference/defs/#ll_binary","title":"<code>ll_binary</code>","text":"<pre><code>ll_binary(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n          compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n          exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n          exposed_interfaces, includes, interfaces, libraries, link_flags, link_string_flags,\n          sanitize, toolchain_configuration)</code></pre> <p>Creates an executable.</p> <p>Example:</p> <p><pre><code>ll_binary(\n    srcs = [\"my_executable.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <p></p>"},{"location":"reference/defs/#ll_compilation_database","title":"<code>ll_compilation_database</code>","text":"<pre><code>ll_compilation_database(name, config, exclude, targets)</code></pre> <p>Executable target for building a compilation database and running clang-tidy on it.</p> <p>For a full guide see Clang-Tidy.</p> <p>See <code>rules_ll/examples</code> for examples. <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>config</code> <code>Label</code>, required. The label of a <code>.clang-tidy</code> configuration file. <code>exclude</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exclude all targets whose path includes one at least one of the provided strings. <code>targets</code> <code>List of labels</code>, required. The labels added to the compilation database. <p></p>"},{"location":"reference/defs/#ll_coverage_test","title":"<code>ll_coverage_test</code>","text":"<pre><code>ll_coverage_test(name, target)</code></pre> <p>TODO <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>target</code> <code>Label</code>, required. The executable to run and collect coverage data from. <p></p>"},{"location":"reference/defs/#ll_library","title":"<code>ll_library</code>","text":"<pre><code>ll_library(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n           compile_string_flags, defines, depends_on_llvm, emit, experimental_device_intrinsics,\n           exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n           exposed_interfaces, includes, interfaces, sanitize, shared_object_link_flags,\n           shared_object_link_string_flags, toolchain_configuration, version_script)</code></pre> <p>Creates a static archive.</p> <p>Example:</p> <p><pre><code>ll_library(\n    srcs = [\"my_library.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>emit</code> <code>List of strings</code>, optional, defaults to <code>[\"archive\"]</code>. Sets the output mode.You can enable several output types at the same time.<code>\"archive\"</code> invokes the archiver and adds an archive with a <code>.a</code> extension to the outputs.<code>\"shared_object\"</code> invokes the linker and adds a shared object with a <code>.so</code> extension to the outputs.<code>\"objects\"</code> adds loose object files to the outputs. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>shared_object_link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>shared_object_link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <code>version_script</code> <code>Label</code>, optional, defaults to <code>None</code>. Optional version script used during shared object linking.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <p></p>"},{"location":"reference/defs/#ll_test","title":"<code>ll_test</code>","text":"<pre><code>ll_test(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n        compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n        exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes, exposed_interfaces,\n        includes, interfaces, libraries, link_flags, link_string_flags, sanitize,\n        toolchain_configuration)</code></pre> <p>Testable wrapper around <code>ll_binary</code>.</p> <p>Consider using this rule over skylib's <code>native_test</code> targets to propagate shared libraries to the test invocations.</p> <p>Example:</p> <p><pre><code>ll_test(\n    name = \"amdgpu_test\",\n    srcs = [\"my_executable.cpp\"],\n    compilation_mode = \"hip_amdgpu\",\n    compile_flags = OFFLOAD_ALL_AMDGPU + [\n        \"-std=c++20\",\n    ],\n    tags = [\"amdgpu\"],  # Not required, but makes grouping tests easier.\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO"},{"location":"reference/driver/","title":"<code>//ll:driver.bzl</code>","text":"<p>Select the C or C++ driver for compile actions.</p> <p></p>"},{"location":"reference/driver/#compiler_driver","title":"<code>compiler_driver</code>","text":"<pre><code>compiler_driver(ctx, in_file)</code></pre> <p>Return either the C or C++ driver, depending on the input file extension.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> A file. <p><code>returns</code></p> <p>The C driver if <code>in_file</code> ends in <code>.c</code>. The C++ driver otherwise.</p>"},{"location":"reference/environment/","title":"<code>//ll:environment.bzl</code>","text":"<p>Environment variables for use in compile and link actions.</p> <p></p>"},{"location":"reference/environment/#compile_object_environment","title":"<code>compile_object_environment</code>","text":"<pre><code>compile_object_environment(ctx)</code></pre> <p>Set environment variables for compile and link actions.</p> <p>For end users this depends on <code>compilation_mode</code> in the <code>ll_library</code> and <code>ll_binary</code> rules.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <p><code>returns</code></p> <p>A <code>dict</code> for use in the <code>environment</code> of an action.</p>"},{"location":"reference/inputs/","title":"<code>//ll:inputs.bzl</code>","text":"<p>Action inputs for rules.</p> <p></p>"},{"location":"reference/inputs/#compilable_sources","title":"<code>compilable_sources</code>","text":"<pre><code>compilable_sources(ctx)</code></pre> <p><code>parameters</code></p> Name Description <code>ctx</code> <p></p>"},{"location":"reference/inputs/#compile_object_inputs","title":"<code>compile_object_inputs</code>","text":"<pre><code>compile_object_inputs(ctx, in_file, headers, interfaces)</code></pre> <p>Collect all inputs for a compile action.</p> <p>Takes files from the arguments and adds files from the <code>srcs</code> and <code>data</code> fields and various toolchain dependencies.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> The input file. <code>headers</code> A <code>depset</code> of headers. <code>interfaces</code> A <code>depset</code> of <code>(interface, name)</code> tuples. <p><code>returns</code></p> <p>A <code>depset</code> of files.</p> <p></p>"},{"location":"reference/inputs/#create_archive_library_inputs","title":"<code>create_archive_library_inputs</code>","text":"<pre><code>create_archive_library_inputs(ctx, in_files)</code></pre> <p><code>parameters</code></p> Name Description <code>ctx</code> <code>in_files</code> <p></p>"},{"location":"reference/inputs/#link_executable_inputs","title":"<code>link_executable_inputs</code>","text":"<pre><code>link_executable_inputs(ctx, in_files)</code></pre> <p>Collect all inputs for link actions producing executables.</p> <p>Apart from <code>in_files</code>, adds files from the <code>deps</code>, <code>libraries</code> and <code>data</code> fields and various toolchain dependencies.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A list of files. <p><code>returns</code></p> <p>A <code>depset</code> of files.</p> <p></p>"},{"location":"reference/inputs/#link_shared_object_inputs","title":"<code>link_shared_object_inputs</code>","text":"<pre><code>link_shared_object_inputs(ctx, in_files)</code></pre> <p>Collect input files for link actions.</p> <p>Adds files from the <code>deps</code> and <code>data</code> fields and various toolchain dependencies.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_files</code> A list of files. <p><code>returns</code></p> <p>A <code>depset</code> of files.</p>"},{"location":"reference/ll/","title":"<code>//ll:ll.bzl</code>","text":"<p>Rules to build C and C++.</p> <p>Build files should import these rules from <code>@rules_ll//ll:defs.bzl</code>.</p> <p></p>"},{"location":"reference/ll/#ll_binary","title":"<code>ll_binary</code>","text":"<pre><code>ll_binary(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n          compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n          exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n          exposed_interfaces, includes, interfaces, libraries, link_flags, link_string_flags,\n          sanitize, toolchain_configuration)</code></pre> <p>Creates an executable.</p> <p>Example:</p> <p><pre><code>ll_binary(\n    srcs = [\"my_executable.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <p></p>"},{"location":"reference/ll/#ll_library","title":"<code>ll_library</code>","text":"<pre><code>ll_library(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n           compile_string_flags, defines, depends_on_llvm, emit, experimental_device_intrinsics,\n           exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n           exposed_interfaces, includes, interfaces, sanitize, shared_object_link_flags,\n           shared_object_link_string_flags, toolchain_configuration, version_script)</code></pre> <p>Creates a static archive.</p> <p>Example:</p> <p><pre><code>ll_library(\n    srcs = [\"my_library.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>emit</code> <code>List of strings</code>, optional, defaults to <code>[\"archive\"]</code>. Sets the output mode.You can enable several output types at the same time.<code>\"archive\"</code> invokes the archiver and adds an archive with a <code>.a</code> extension to the outputs.<code>\"shared_object\"</code> invokes the linker and adds a shared object with a <code>.so</code> extension to the outputs.<code>\"objects\"</code> adds loose object files to the outputs. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>shared_object_link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>shared_object_link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <code>version_script</code> <code>Label</code>, optional, defaults to <code>None</code>. Optional version script used during shared object linking.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <p></p>"},{"location":"reference/ll/#ll_test","title":"<code>ll_test</code>","text":"<pre><code>ll_test(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n        compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n        exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes, exposed_interfaces,\n        includes, interfaces, libraries, link_flags, link_string_flags, sanitize,\n        toolchain_configuration)</code></pre> <p>Testable wrapper around <code>ll_binary</code>.</p> <p>Consider using this rule over skylib's <code>native_test</code> targets to propagate shared libraries to the test invocations.</p> <p>Example:</p> <p><pre><code>ll_test(\n    name = \"amdgpu_test\",\n    srcs = [\"my_executable.cpp\"],\n    compilation_mode = \"hip_amdgpu\",\n    compile_flags = OFFLOAD_ALL_AMDGPU + [\n        \"-std=c++20\",\n    ],\n    tags = [\"amdgpu\"],  # Not required, but makes grouping tests easier.\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO"},{"location":"reference/llvm_project_deps/","title":"<code>//ll:llvm_project_deps.bzl</code>","text":"<p>Targets from the <code>llvm-project-overlay</code> used in <code>depends_on_llvm</code>.</p>"},{"location":"reference/outputs/","title":"<code>//ll:outputs.bzl</code>","text":"<p>Action outputs.</p> <p></p>"},{"location":"reference/outputs/#compile_object_outputs","title":"<code>compile_object_outputs</code>","text":"<pre><code>compile_object_outputs(ctx, in_file)</code></pre> <p>Given a compilable file, return an output name for the compiled object.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> A <code>file</code>. <p><code>returns</code></p> <p>A tuple <code>(out_file, cdf)</code>. Outputs end with <code>.o</code>/<code>.cdf</code> or   <code>.interface.o</code>/<code>.interface.cdf</code>, if <code>in_file</code> has a <code>.pcm</code> extension.</p> <p></p>"},{"location":"reference/outputs/#create_archive_library_outputs","title":"<code>create_archive_library_outputs</code>","text":"<pre><code>create_archive_library_outputs(ctx)</code></pre> <p>For a label <code>filename</code> return a file <code>filename.a</code>.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> <p></p>"},{"location":"reference/outputs/#link_executable_outputs","title":"<code>link_executable_outputs</code>","text":"<pre><code>link_executable_outputs(ctx)</code></pre> <p>For a label <code>filename</code> return a file of the same name.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> <p></p>"},{"location":"reference/outputs/#link_shared_object_outputs","title":"<code>link_shared_object_outputs</code>","text":"<pre><code>link_shared_object_outputs(ctx)</code></pre> <p>For a label <code>filename</code> return a file <code>filename.so</code>.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> <p></p>"},{"location":"reference/outputs/#ll_artifact","title":"<code>ll_artifact</code>","text":"<pre><code>ll_artifact(ctx, filename)</code></pre> <p>Return a string of the form <code>\"{ctx.label.name}/filename\"</code>.</p> <p>Encapsulate intermediary build artifacts to avoid name clashes for files of the same name built by targets in the same build invocation.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The build context. <code>filename</code> defaults to <code>None</code>.An optional string representing a filename. If omitted, creates a path of the form <code>\"{ctx.label.name}\"</code>. <p></p>"},{"location":"reference/outputs/#precompile_interface_outputs","title":"<code>precompile_interface_outputs</code>","text":"<pre><code>precompile_interface_outputs(ctx, in_file)</code></pre> <p>Given a file <code>f.cppm</code> return files <code>f.pcm</code> and <code>f.pcm.cdf</code>.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <code>in_file</code> A <code>file</code>. <p><code>returns</code></p> <p>A tuple <code>(out_file, cdf)</code>.</p>"},{"location":"reference/providers/","title":"<code>//ll:providers.bzl</code>","text":"<p>Providers for the <code>ll_binary</code>, <code>ll_library</code> and <code>ll_compilation_database</code> rules.</p> <p></p>"},{"location":"reference/providers/#llcompilationdatabasefragmentsinfo","title":"<code>LlCompilationDatabaseFragmentsInfo</code>","text":"<pre><code>LlCompilationDatabaseFragmentsInfo(cdfs)</code></pre> <p>Stores compilation database fragments.</p> <p><code>fields</code></p> Name Description <code>cdfs</code> A <code>depset</code> of compilation database fragments. <p></p>"},{"location":"reference/providers/#llcompilationdatabaseinfo","title":"<code>LlCompilationDatabaseInfo</code>","text":"<pre><code>LlCompilationDatabaseInfo(compilation_database)</code></pre> <p>Provider for a compilation database.</p> <p><code>fields</code></p> Name Description <code>compilation_database</code> A <code>compile_commands.json</code> file.This file stores the compilation database. <p></p>"},{"location":"reference/providers/#llinfo","title":"<code>LlInfo</code>","text":"<pre><code>LlInfo(exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes, exposed_bmis)</code></pre> <p>The default provider returned by an <code>ll_*</code> target.</p> <p><code>fields</code></p> Name Description <code>exposed_angled_includes</code> A <code>depset</code> of angled includes. <code>exposed_defines</code> A <code>depset</code> of defines. <code>exposed_hdrs</code> A <code>depset</code> of header files. <code>exposed_includes</code> A <code>depset</code> of includes. <code>exposed_bmis</code> A <code>depset</code> of <code>LlModuleInfo</code> providers. <p></p>"},{"location":"reference/providers/#llmoduleinfo","title":"<code>LlModuleInfo</code>","text":"<pre><code>LlModuleInfo(module_name, bmi)</code></pre> <p>Provider for a module.</p> <p><code>fields</code></p> Name Description <code>module_name</code> The name of the module. <code>bmi</code> The precompiled module interface."},{"location":"reference/resolve_rule_inputs/","title":"<code>//ll:resolve_rule_inputs.bzl</code>","text":"<p>Resolve the inputs to <code>ll_library</code> and <code>ll_binary</code> rules.</p> <p></p>"},{"location":"reference/resolve_rule_inputs/#expand_includes","title":"<code>expand_includes</code>","text":"<pre><code>expand_includes(ctx, include_string)</code></pre> <p>Prefix <code>include_string</code> with the path to the workspace root.</p> <p>If <code>include_string</code> starts with <code>$(GENERATED)</code>, prefixes with the<code>GENDIR</code> path as well.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> <code>include_string</code> <p></p>"},{"location":"reference/resolve_rule_inputs/#resolve_rule_inputs","title":"<code>resolve_rule_inputs</code>","text":"<pre><code>resolve_rule_inputs(ctx)</code></pre> <p>Gather the inputs for downstream actions.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <p><code>returns</code></p> <p>A tuple <code>(hdrs, defines, includes, angled_includes, bmis)</code>. See   //ll:actions.bzl for usage.</p>"},{"location":"reference/toolchain/","title":"<code>//ll:toolchain.bzl</code>","text":"<p>This file declares the <code>ll_toolchain</code> rule.</p> <p></p>"},{"location":"reference/toolchain/#ll_toolchain","title":"<code>ll_toolchain</code>","text":"<pre><code>ll_toolchain(name, LL_AMD_INCLUDES, LL_AMD_LIBRARIES, LL_CFLAGS, LL_CUDA_DRIVER, LL_CUDA_NVCC,\n             LL_CUDA_NVCC_CFLAGS, LL_CUDA_NVCC_LDFLAGS, LL_CUDA_TOOLKIT, LL_DYNAMIC_LINKER,\n             LL_LDFLAGS, address_sanitizer, archiver, bitcode_linker, builtin_includes, c_driver,\n             clang_tidy, clang_tidy_runner, compiler_runtime, cov, cpp_abihdrs, cpp_abilib,\n             cpp_driver, cpp_stdhdrs, cpp_stdlib, hip_libraries, hip_runtime, leak_sanitizer, linker,\n             linker_wrapper, llvm_project_deps, machine_code_tool, memory_sanitizer, objcopy,\n             offload_bundler, offload_packager, opt, profdata, profile, rocm_device_libs, symbolizer,\n             thread_sanitizer, undefined_behavior_sanitizer, unwind_library)</code></pre> <p><code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>LL_AMD_INCLUDES</code> <code>Label</code>, optional, defaults to <code>None</code>. System includes for dependencies making use of AMD toolchains.Affects the <code>hip_amdgpu</code> and <code>hip_nvptx</code> toolchains. <code>LL_AMD_LIBRARIES</code> <code>Label</code>, optional, defaults to <code>None</code>. Link search paths for dependencies making use of AMD toolchains.Affects the <code>hip_amdgpu</code> toolchain. <code>LL_CFLAGS</code> <code>Label</code>, optional, defaults to <code>None</code>. Arbitrary flags added to all compile actions. <code>LL_CUDA_DRIVER</code> <code>Label</code>, optional, defaults to <code>None</code>. The path to the CUDA driver.Affects the <code>cuda_nvptx</code> and <code>hip_nvptx</code> toolchains. <code>LL_CUDA_NVCC</code> <code>Label</code>, optional, defaults to <code>None</code>. The path to the <code>nvcc</code> compiler.Affects the <code>cuda_nvptx_nvcc</code> toolchain. Other <code>*_nvptx</code> toolchains use the <code>c_driver</code> or <code>cpp_driver</code> as device compiler. <code>LL_CUDA_NVCC_CFLAGS</code> <code>Label</code>, optional, defaults to <code>None</code>. Compile flags used by the <code>cuda_nvptx_nvcc</code> toolchain. <code>LL_CUDA_NVCC_LDFLAGS</code> <code>Label</code>, optional, defaults to <code>None</code>. Link flags used by the <code>cuda_nvptx_nvcc</code> toolchain. <code>LL_CUDA_TOOLKIT</code> <code>Label</code>, optional, defaults to <code>None</code>. The path to the CUDA toolkit.Affects the <code>cuda_nvptx</code> and <code>hip_nvptx</code> toolchains. <code>LL_DYNAMIC_LINKER</code> <code>Label</code>, optional, defaults to <code>None</code>. The linker from the glibc we compile and link against. <code>LL_LDFLAGS</code> <code>Label</code>, optional, defaults to <code>None</code>. Arbitrary flags added to all link actions. <code>address_sanitizer</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. AddressSanitizer libraries. <code>archiver</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-ar\"</code>. The archiver. <code>bitcode_linker</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-link\"</code>. The linker for LLVM bitcode files. <code>builtin_includes</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang:builtin_headers_gen\"</code>. Clang's built-in header files. <code>c_driver</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang\"</code>. The C compiler driver. <code>clang_tidy</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang-tools-extra/clang-tidy\"</code>. The clang-tidy binary. <code>clang_tidy_runner</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang-tools-extra/clang-tidy:run-clang-tidy\"</code>. The <code>run-clang-tidy.py</code> wrapper script for clang-tidy. <code>compiler_runtime</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The compiler runtime. <code>cov</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-cov\"</code>. The <code>llvm-cov</code> tool. <code>cpp_abihdrs</code> <code>Label</code>, optional, defaults to <code>None</code>. The C++ ABI headers. <code>cpp_abilib</code> <code>Label</code>, optional, defaults to <code>None</code>. The C++ ABI library archive. <code>cpp_driver</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang:clang++\"</code>. The C++ compiler driver. <code>cpp_stdhdrs</code> <code>Label</code>, optional, defaults to <code>None</code>. The C++ standard library headers. <code>cpp_stdlib</code> <code>Label</code>, optional, defaults to <code>None</code>. The C++ standard library. <code>hip_libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The HIP libraries.<code>rules_ll</code> still uses <code>clang</code> to compile device code.Using this implies acceptance of the AMD's license for HIP.Using HIP to target Nvidia devices implies use of the Nvidia CUDA toolkit. <code>hip_runtime</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The libamdhip64 runtime. <code>leak_sanitizer</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. LeakSanitizer libraries. <code>linker</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//lld\"</code>. The linker.Called by the <code>clang-linker-wrapper</code>. <code>linker_wrapper</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang:clang-linker-wrapper\"</code>. The <code>clang-linker-wrapper</code>.This wraps the host linker and the device linkers. <code>llvm_project_deps</code> <code>List of labels</code>, optional, defaults to <code>[\"@llvm-project//clang:analysis\", \"@llvm-project//clang:apinotes\", \"@llvm-project//clang:arc_migrate\", \"@llvm-project//clang:ast\", \"@llvm-project//clang:ast-diff\", \"@llvm-project//clang:ast_matchers\", \"@llvm-project//clang:ast_matchers_dynamic\", \"@llvm-project//clang:basic\", \"@llvm-project//clang:clang-driver\", \"@llvm-project//clang:codegen\", \"@llvm-project//clang:config\", \"@llvm-project//clang:crosstu\", \"@llvm-project//clang:driver\", \"@llvm-project//clang:edit\", \"@llvm-project//clang:extract_api\", \"@llvm-project//clang:format\", \"@llvm-project//clang:frontend\", \"@llvm-project//clang:frontend_rewrite\", \"@llvm-project//clang:frontend_tool\", \"@llvm-project//clang:index\", \"@llvm-project//clang:install_api\", \"@llvm-project//clang:interpreter\", \"@llvm-project//clang:lex\", \"@llvm-project//clang:libclang\", \"@llvm-project//clang:libclang_static\", \"@llvm-project//clang:parse\", \"@llvm-project//clang:rewrite\", \"@llvm-project//clang:sema\", \"@llvm-project//clang:serialization\", \"@llvm-project//clang:static_analyzer_checkers\", \"@llvm-project//clang:static_analyzer_core\", \"@llvm-project//clang:static_analyzer_core_options\", \"@llvm-project//clang:static_analyzer_frontend\", \"@llvm-project//clang:support\", \"@llvm-project//clang:tooling\", \"@llvm-project//clang:tooling_core\", \"@llvm-project//clang:tooling_dependency_scanning\", \"@llvm-project//clang:tooling_inclusions\", \"@llvm-project//clang:tooling_refactoring\", \"@llvm-project//clang:tooling_syntax\", \"@llvm-project//clang:transformer\", \"@llvm-project//llvm:AggressiveInstCombine\", \"@llvm-project//llvm:AllTargetsAsmParsers\", \"@llvm-project//llvm:AllTargetsCodeGens\", \"@llvm-project//llvm:AllTargetsDisassemblers\", \"@llvm-project//llvm:AllTargetsMCAs\", \"@llvm-project//llvm:Analysis\", \"@llvm-project//llvm:AsmParser\", \"@llvm-project//llvm:BinaryFormat\", \"@llvm-project//llvm:BitReader\", \"@llvm-project//llvm:BitWriter\", \"@llvm-project//llvm:BitstreamReader\", \"@llvm-project//llvm:BitstreamWriter\", \"@llvm-project//llvm:CFGuard\", \"@llvm-project//llvm:CodeGen\", \"@llvm-project//llvm:CodeGenTypes\", \"@llvm-project//llvm:Core\", \"@llvm-project//llvm:Coroutines\", \"@llvm-project//llvm:Coverage\", \"@llvm-project//llvm:DWP\", \"@llvm-project//llvm:DebugInfo\", \"@llvm-project//llvm:DebugInfoBTF\", \"@llvm-project//llvm:DebugInfoCodeView\", \"@llvm-project//llvm:DebugInfoDWARF\", \"@llvm-project//llvm:DebugInfoGSYM\", \"@llvm-project//llvm:DebugInfoLogicalView\", \"@llvm-project//llvm:DebugInfoMSF\", \"@llvm-project//llvm:DebugInfoPDB\", \"@llvm-project//llvm:Debuginfod\", \"@llvm-project//llvm:Demangle\", \"@llvm-project//llvm:ExecutionEngine\", \"@llvm-project//llvm:FileCheckLib\", \"@llvm-project//llvm:FrontendDriver\", \"@llvm-project//llvm:FrontendHLSL\", \"@llvm-project//llvm:FrontendOffloading\", \"@llvm-project//llvm:FrontendOpenACC\", \"@llvm-project//llvm:FrontendOpenMP\", \"@llvm-project//llvm:HipStdPar\", \"@llvm-project//llvm:IPO\", \"@llvm-project//llvm:IRPrinter\", \"@llvm-project//llvm:IRReader\", \"@llvm-project//llvm:InstCombine\", \"@llvm-project//llvm:Instrumentation\", \"@llvm-project//llvm:InterfaceStub\", \"@llvm-project//llvm:Interpreter\", \"@llvm-project//llvm:LTO\", \"@llvm-project//llvm:LibDriver\", \"@llvm-project//llvm:LineEditor\", \"@llvm-project//llvm:Linker\", \"@llvm-project//llvm:TableGenGlobalISel\", \"@llvm-project//llvm:MC\", \"@llvm-project//llvm:MCA\", \"@llvm-project//llvm:MCDisassembler\", \"@llvm-project//llvm:MCParser\", \"@llvm-project//llvm:ObjCARC\", \"@llvm-project//llvm:Object\", \"@llvm-project//llvm:ObjectYAML\", \"@llvm-project//llvm:Option\", \"@llvm-project//llvm:Passes\", \"@llvm-project//llvm:ProfileData\", \"@llvm-project//llvm:Remarks\", \"@llvm-project//llvm:Scalar\", \"@llvm-project//llvm:Support\", \"@llvm-project//llvm:Symbolize\", \"@llvm-project//llvm:TableGen\", \"@llvm-project//llvm:Target\", \"@llvm-project//llvm:TargetParser\", \"@llvm-project//llvm:TextAPI\", \"@llvm-project//llvm:TransformUtils\", \"@llvm-project//llvm:Vectorize\", \"@llvm-project//llvm:WindowsDriver\", \"@llvm-project//llvm:attributes_gen\", \"@llvm-project//llvm:common_transforms\", \"@llvm-project//llvm:config\", \"@llvm-project//llvm:remark_linker\", \"@llvm-project//lld:ELF\", \"@llvm-project//lld:Common\", \"@zlib-ng//:zlib\", \"@zstd\", \"@llvm-project//llvm:AMDGPUCodeGen\", \"@llvm-project//llvm:AMDGPUDisassembler\", \"@llvm-project//llvm:AMDGPUAsmParser\", \"@llvm-project//llvm:AMDGPUTargetMCA\", \"@llvm-project//llvm:AMDGPUUtilsAndDesc\", \"@llvm-project//llvm:AMDGPUInfo\", \"@llvm-project//llvm:WebAssemblyCodeGen\", \"@llvm-project//llvm:WebAssemblyDisassembler\", \"@llvm-project//llvm:WebAssemblyAsmParser\", \"@llvm-project//llvm:WebAssemblyTargetMCA\", \"@llvm-project//llvm:WebAssemblyUtilsAndDesc\", \"@llvm-project//llvm:WebAssemblyInfo\", \"@llvm-project//llvm:AArch64CodeGen\", \"@llvm-project//llvm:AArch64Disassembler\", \"@llvm-project//llvm:AArch64AsmParser\", \"@llvm-project//llvm:AArch64TargetMCA\", \"@llvm-project//llvm:AArch64UtilsAndDesc\", \"@llvm-project//llvm:AArch64Info\", \"@llvm-project//llvm:BPFCodeGen\", \"@llvm-project//llvm:BPFDisassembler\", \"@llvm-project//llvm:BPFAsmParser\", \"@llvm-project//llvm:BPFTargetMCA\", \"@llvm-project//llvm:BPFUtilsAndDesc\", \"@llvm-project//llvm:BPFInfo\", \"@llvm-project//llvm:LanaiCodeGen\", \"@llvm-project//llvm:LanaiDisassembler\", \"@llvm-project//llvm:LanaiAsmParser\", \"@llvm-project//llvm:LanaiTargetMCA\", \"@llvm-project//llvm:LanaiUtilsAndDesc\", \"@llvm-project//llvm:LanaiInfo\", \"@llvm-project//llvm:MSP430CodeGen\", \"@llvm-project//llvm:MSP430Disassembler\", \"@llvm-project//llvm:MSP430AsmParser\", \"@llvm-project//llvm:MSP430TargetMCA\", \"@llvm-project//llvm:MSP430UtilsAndDesc\", \"@llvm-project//llvm:MSP430Info\", \"@llvm-project//llvm:AVRCodeGen\", \"@llvm-project//llvm:AVRDisassembler\", \"@llvm-project//llvm:AVRAsmParser\", \"@llvm-project//llvm:AVRTargetMCA\", \"@llvm-project//llvm:AVRUtilsAndDesc\", \"@llvm-project//llvm:AVRInfo\", \"@llvm-project//llvm:HexagonCodeGen\", \"@llvm-project//llvm:HexagonDisassembler\", \"@llvm-project//llvm:HexagonAsmParser\", \"@llvm-project//llvm:HexagonTargetMCA\", \"@llvm-project//llvm:HexagonUtilsAndDesc\", \"@llvm-project//llvm:HexagonInfo\", \"@llvm-project//llvm:VECodeGen\", \"@llvm-project//llvm:VEDisassembler\", \"@llvm-project//llvm:VEAsmParser\", \"@llvm-project//llvm:VETargetMCA\", \"@llvm-project//llvm:VEUtilsAndDesc\", \"@llvm-project//llvm:VEInfo\", \"@llvm-project//llvm:NVPTXCodeGen\", \"@llvm-project//llvm:NVPTXDisassembler\", \"@llvm-project//llvm:NVPTXAsmParser\", \"@llvm-project//llvm:NVPTXTargetMCA\", \"@llvm-project//llvm:NVPTXUtilsAndDesc\", \"@llvm-project//llvm:NVPTXInfo\", \"@llvm-project//llvm:XCoreCodeGen\", \"@llvm-project//llvm:XCoreDisassembler\", \"@llvm-project//llvm:XCoreAsmParser\", \"@llvm-project//llvm:XCoreTargetMCA\", \"@llvm-project//llvm:XCoreUtilsAndDesc\", \"@llvm-project//llvm:XCoreInfo\", \"@llvm-project//llvm:X86CodeGen\", \"@llvm-project//llvm:X86Disassembler\", \"@llvm-project//llvm:X86AsmParser\", \"@llvm-project//llvm:X86TargetMCA\", \"@llvm-project//llvm:X86UtilsAndDesc\", \"@llvm-project//llvm:X86Info\", \"@llvm-project//llvm:RISCVCodeGen\", \"@llvm-project//llvm:RISCVDisassembler\", \"@llvm-project//llvm:RISCVAsmParser\", \"@llvm-project//llvm:RISCVTargetMCA\", \"@llvm-project//llvm:RISCVUtilsAndDesc\", \"@llvm-project//llvm:RISCVInfo\", \"@llvm-project//llvm:MipsCodeGen\", \"@llvm-project//llvm:MipsDisassembler\", \"@llvm-project//llvm:MipsAsmParser\", \"@llvm-project//llvm:MipsTargetMCA\", \"@llvm-project//llvm:MipsUtilsAndDesc\", \"@llvm-project//llvm:MipsInfo\", \"@llvm-project//llvm:PowerPCCodeGen\", \"@llvm-project//llvm:PowerPCDisassembler\", \"@llvm-project//llvm:PowerPCAsmParser\", \"@llvm-project//llvm:PowerPCTargetMCA\", \"@llvm-project//llvm:PowerPCUtilsAndDesc\", \"@llvm-project//llvm:PowerPCInfo\", \"@llvm-project//llvm:SystemZCodeGen\", \"@llvm-project//llvm:SystemZDisassembler\", \"@llvm-project//llvm:SystemZAsmParser\", \"@llvm-project//llvm:SystemZTargetMCA\", \"@llvm-project//llvm:SystemZUtilsAndDesc\", \"@llvm-project//llvm:SystemZInfo\", \"@llvm-project//llvm:ARMCodeGen\", \"@llvm-project//llvm:ARMDisassembler\", \"@llvm-project//llvm:ARMAsmParser\", \"@llvm-project//llvm:ARMTargetMCA\", \"@llvm-project//llvm:ARMUtilsAndDesc\", \"@llvm-project//llvm:ARMInfo\", \"@llvm-project//llvm:SparcCodeGen\", \"@llvm-project//llvm:SparcDisassembler\", \"@llvm-project//llvm:SparcAsmParser\", \"@llvm-project//llvm:SparcTargetMCA\", \"@llvm-project//llvm:SparcUtilsAndDesc\", \"@llvm-project//llvm:SparcInfo\"]</code>. Targets from the <code>llvm-project-overlay</code>.Useful for targets that depend on the <code>llvm-project</code>. For instance frontend actions and Clang plugins. <code>machine_code_tool</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-mc\"</code>. The <code>llvm-mc</code> tool.Used when building CUDA and HIP with <code>-fgpu-rdc</code>.. <code>memory_sanitizer</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. MemorySanitizer libraries. <code>objcopy</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-objcopy\"</code>. The <code>llvm-objcopy</code> tool. <code>offload_bundler</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang:clang-offload-bundler\"</code>. The <code>clang-offload-bundler</code>.Bundles the device code objects for GPU code. <code>offload_packager</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//clang:clang-offload-packager\"</code>. The <code>clang-offload-packager</code>. <code>opt</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:opt\"</code>. The LLVM <code>opt</code> tool. <code>profdata</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-profdata\"</code>. The <code>llvm-profdata</code> tool. <code>profile</code> <code>Label</code>, optional, defaults to <code>None</code>. The clang_rt.profile implementation <code>rocm_device_libs</code> <code>Label</code>, optional, defaults to <code>None</code>. The ROCm-Device-Libs. <code>symbolizer</code> <code>Label</code>, optional, defaults to <code>\"@llvm-project//llvm:llvm-symbolizer\"</code>. The <code>llvm-symbolizer</code>. <code>thread_sanitizer</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. ThreadSanitizer libraries. <code>undefined_behavior_sanitizer</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. UndefinedBehaviorSanitizer libraries. <code>unwind_library</code> <code>Label</code>, optional, defaults to <code>None</code>. The unwinder library."},{"location":"reference/tools/","title":"<code>//ll:tools.bzl</code>","text":"<p>Tools used by actions.</p> <p></p>"},{"location":"reference/tools/#compile_object_tools","title":"<code>compile_object_tools</code>","text":"<pre><code>compile_object_tools(ctx)</code></pre> <p>Tools for use in compile actions.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <p><code>returns</code></p> <p>A list of labels.</p> <p></p>"},{"location":"reference/tools/#linking_tools","title":"<code>linking_tools</code>","text":"<pre><code>linking_tools(ctx)</code></pre> <p>Tools for use in link actions.</p> <p><code>parameters</code></p> Name Description <code>ctx</code> The rule context. <p><code>returns</code></p> <p>A list of labels.</p>"},{"location":"reference/transitions/","title":"<code>//ll:transitions.bzl</code>","text":"<p>Transitions used by the <code>ll_toolchain</code> rule.</p>"},{"location":"rules/defs/","title":"<code>//ll:defs.bzl</code>","text":"<p>Import these rules in your <code>BUILD.bazel</code> files.</p> <p>To load for example the <code>ll_binary</code> rule:</p> <pre><code>load(\"@rules_ll//ll:defs.bzl\", \"ll_binary\")\n</code></pre> <p></p>"},{"location":"rules/defs/#ll_binary","title":"<code>ll_binary</code>","text":"<pre><code>ll_binary(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n          compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n          exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n          exposed_interfaces, includes, interfaces, libraries, link_flags, link_string_flags,\n          sanitize, toolchain_configuration)</code></pre> <p>Creates an executable.</p> <p>Example:</p> <p><pre><code>ll_binary(\n    srcs = [\"my_executable.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <p></p>"},{"location":"rules/defs/#ll_compilation_database","title":"<code>ll_compilation_database</code>","text":"<pre><code>ll_compilation_database(name, config, exclude, targets)</code></pre> <p>Executable target for building a compilation database and running clang-tidy on it.</p> <p>For a full guide see Clang-Tidy.</p> <p>See <code>rules_ll/examples</code> for examples. <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>config</code> <code>Label</code>, required. The label of a <code>.clang-tidy</code> configuration file. <code>exclude</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exclude all targets whose path includes one at least one of the provided strings. <code>targets</code> <code>List of labels</code>, required. The labels added to the compilation database. <p></p>"},{"location":"rules/defs/#ll_coverage_test","title":"<code>ll_coverage_test</code>","text":"<pre><code>ll_coverage_test(name, target)</code></pre> <p>TODO <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>target</code> <code>Label</code>, required. The executable to run and collect coverage data from. <p></p>"},{"location":"rules/defs/#ll_library","title":"<code>ll_library</code>","text":"<pre><code>ll_library(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n           compile_string_flags, defines, depends_on_llvm, emit, experimental_device_intrinsics,\n           exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes,\n           exposed_interfaces, includes, interfaces, sanitize, shared_object_link_flags,\n           shared_object_link_string_flags, toolchain_configuration, version_script)</code></pre> <p>Creates a static archive.</p> <p>Example:</p> <p><pre><code>ll_library(\n    srcs = [\"my_library.cpp\"],\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>emit</code> <code>List of strings</code>, optional, defaults to <code>[\"archive\"]</code>. Sets the output mode.You can enable several output types at the same time.<code>\"archive\"</code> invokes the archiver and adds an archive with a <code>.a</code> extension to the outputs.<code>\"shared_object\"</code> invokes the linker and adds a shared object with a <code>.so</code> extension to the outputs.<code>\"objects\"</code> adds loose object files to the outputs. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>shared_object_link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>shared_object_link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker when emitting shared objects in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO <code>version_script</code> <code>Label</code>, optional, defaults to <code>None</code>. Optional version script used during shared object linking.Used if <code>emit</code> includes <code>\"shared_object\"</code>. <p></p>"},{"location":"rules/defs/#ll_test","title":"<code>ll_test</code>","text":"<pre><code>ll_test(name, deps, srcs, data, hdrs, angled_includes, compilation_mode, compile_flags,\n        compile_string_flags, defines, depends_on_llvm, experimental_device_intrinsics,\n        exposed_angled_includes, exposed_defines, exposed_hdrs, exposed_includes, exposed_interfaces,\n        includes, interfaces, libraries, link_flags, link_string_flags, sanitize,\n        toolchain_configuration)</code></pre> <p>Testable wrapper around <code>ll_binary</code>.</p> <p>Consider using this rule over skylib's <code>native_test</code> targets to propagate shared libraries to the test invocations.</p> <p>Example:</p> <p><pre><code>ll_test(\n    name = \"amdgpu_test\",\n    srcs = [\"my_executable.cpp\"],\n    compilation_mode = \"hip_amdgpu\",\n    compile_flags = OFFLOAD_ALL_AMDGPU + [\n        \"-std=c++20\",\n    ],\n    tags = [\"amdgpu\"],  # Not required, but makes grouping tests easier.\n)\n</code></pre> <code>attributes</code></p> Name Description <code>name</code> <code>Name</code>, required. A unique name for this target. <code>deps</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. The dependencies for this target.Use <code>ll_library</code> targets here. Other targets won't work. <code>srcs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Compilable source files for this target.Allowed file extensions: <code>[\".ll\", \".o\", \".S\", \".c\", \".cl\", \".cpp\"]</code>.Place headers in the <code>hdrs</code> attribute. <code>data</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Extra files made available to compilation and linking steps.Not appended to the default command line arguments, but available to actions. Reference these files manually for instance in the <code>includes</code>, and <code>compile_flags</code> attributes.Use this attribute to make intermediary outputs from non-ll targets, for example from <code>rules_cc</code> or <code>filegroup</code>, available to the rule. <code>hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Header files for this target.When including a header file with a nested path, for instance <code>#include \"some/path/myheader.h\"</code>, add <code>\"some/path\"</code> to <code>includes</code> to make it visible to the rule.Unavailable to downstream targets. <code>angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Angled include paths, relative to the target workspace.Useful if you require include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-Iexternal/mydep.someversion/include\"]</code>, use <code>angled_includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>compilation_mode</code> <code>String</code>, optional, defaults to <code>\"cpp\"</code>. Enables compilation of heterogeneous single source files.Prefer this attribute over adding SYCL/HIP/CUDA flags manually in the <code>compile_flags</code> and <code>link_flags</code>.See CUDA and HIP.<code>\"cpp\"</code> The default C++ toolchain.<code>\"cuda_nvptx\"</code> The CUDA toolchain.<code>\"cuda_nvptx_nvcc\"</code> The CUDA toolchain with <code>nvcc</code> as device compiler.<code>\"hip_nvptx\"</code> The HIP toolchain.<code>\"bootstrap\"</code> The bootstrap toolchain used by internal dependencies of the <code>ll_toolchain</code>. <code>compile_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the compiler.Pass a list of strings here. For instance <code>[\"-O3\", \"-std=c++20\"]</code>.Split flag pairs <code>-Xclang -somearg</code> into separate flags <code>[\"-Xclang\", \"-somearg\"]</code>.Unavailable to downstream targets. <code>compile_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the compiler in the form of <code>string_flag</code>s.Splits the values of each <code>string_flag</code> along colons like so:<pre><code>load(\"@bazel_skylib//rules:common_settings.bzl\", \"string_flag\")\n\nstring_flag(\n    name = \"myflags\",\n    build_setting_default = \"a:b:c\",\n)\n\nll_library(\n    # ...\n    # Equivalent to <code>compile_flags = [\"a\", \"b\", \"c\"]</code>\n    compile_string_flags = [\":myflags\"],\n)</code></pre>Useful for externally configurable build attributes, such as generated flags from Nix environments. <code>defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Defines for this target.Pass a list of strings here. For instance <code>[\"MYDEFINE_1\", \"MYDEFINE_2\"]</code>.Unavailable to downstream targets. <code>depends_on_llvm</code> <code>Boolean</code>, optional, defaults to <code>False</code>. Whether this target directly depends on targets from the <code>llvm-project-overlay</code>.Setting this to <code>True</code> makes the <code>cc_library</code> targets from the LLVM project overlay available to this target. <code>experimental_device_intrinsics</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Custom intrinsics for device compilation.Adds <code>-Xarch_device -include&lt;thefile&gt;</code> to the compile commands for this target. <code>exposed_angled_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed angled include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_defines</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed defines for this target.Added to the compile command line arguments of direct dependents. <code>exposed_hdrs</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Exposed headers for this target.Direct dependents can see exposed headers. Put the public API headers for libraries here. <code>exposed_includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Exposed include paths, relative to the original target workspace.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Added to the compile command line arguments of direct dependents. <code>exposed_interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Transitive interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents. Files in this attribute can see BMIs from modules in <code>interfaces</code>.Primary module interfaces go here. <code>includes</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Include paths, relative to the target workspace.Uses <code>-iquote</code>.Useful if you need custom include prefix stripping for dynamic paths, for instance the ones generated by <code>bzlmod</code>. Instead of <code>compile_flags = [\"-iquoteexternal/mydep.someversion/include\"]</code>, use <code>includes = [\"include\"]</code> to add the path to the workspace automatically.Expands paths starting with <code>$(GENERATED)</code> to the workspace location in the <code>GENDIR</code> path.Unavailable to downstream targets. <code>interfaces</code> <code>Dictionary: Label -&gt; String</code>, optional, defaults to <code>{}</code>. Module interfaces for this target.See C++ modules for a guide.Makes precompiled modules and compiled objects visible to direct dependents and to <code>exposed_interfaces</code>.For instance, you can put module partitions in <code>interfaces</code> and the primary module interface in <code>exposed_interfaces</code>.Files in the same <code>interfaces</code> attribute can't see each other's BMIs. <code>libraries</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Libraries linked to the final executable.Adds these libraries to the command line arguments for the linker. <code>link_flags</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Flags for the linker.Place library search paths and external link targets here.Assuming you have a library <code>/some/path/libmylib.a</code> on your host system, you can make <code>mylib.a</code> available to the linker by passing <code>[\"-L/some/path\", \"-lmylib\"]</code> to this attribute.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>link_string_flags</code> <code>List of labels</code>, optional, defaults to <code>[]</code>. Flags for the linker in the form of <code>string_flag</code>s.See <code>compile_string_flags</code> for semantics.Prefer the <code>libraries</code> attribute for library files already present within the Bazel build graph. <code>sanitize</code> <code>List of strings</code>, optional, defaults to <code>[]</code>. Enable sanitizers for this target.See the Sanitizers guide.Some sanitizers come with heavy performance penalties. Enabling several sanitizers at the same time often breaks builds. If possible, use just one at a time.Sanitizers produce nondeterministic error reports. Run sanitized executables several times and build them with different optimization levels to maximize coverage.<code>\"address\"</code>: Enable AddressSanitizer to detect memory errors.<code>\"leak\"</code>: Enable LeakSanitizer to detect memory leaks.<code>\"memory\"</code>: Enable MemorySanitizer to detect uninitialized reads.<code>\"undefined_behavior\"</code>: Enable UndefinedBehaviorSanitizer to detect     undefined behavior.<code>\"thread\"</code>: Enable ThreadSanitizer to detect data races. <code>toolchain_configuration</code> <code>Label</code>, optional, defaults to <code>\"@rules_ll//ll:current_ll_toolchain_configuration\"</code>. TODO"},{"location":"setup/remote_execution/","title":"Remote execution","text":""},{"location":"setup/remote_execution/#remote-caching-and-execution","title":"Remote caching and execution","text":"<p><code>rules_ll</code> uses remote execution compatible toolchains by default, even when you run local builds.</p> <p><code>rules_ll</code> extends Local Remote Execution (LRE) which disables Bazel's toolchain auto detection and pins every tool to a reproducible artifact from <code>nixpkgs</code>. This way every system running the same version of <code>rules_ll</code> uses the same toolchain, regardless of the host's operating system and locally installed toolchains.</p> <p>Similar to LRE, the remote execution toolchains in <code>rules_ll</code> achieve virtually perfect cache hit rates even among different systems sharing the same cache.</p> <p>Warning</p> <p>A single compromised machine with write access to a remote cache can easily trigger malicious code execution on all machines reading from that cache.</p>"},{"location":"setup/remote_execution/#local-remote-cache","title":"Local remote cache","text":"<p>If you just want to share build results between different directories on the same machine, use a local remote cache. Consider using at least this setup with <code>rules_ll</code>. The initial build of the LLVM project can take a long time and you probably don't want to rebuild LLVM every time you start a new project.</p> <p></p> <ol> <li>Set up a remote cache like NativeLink.</li> <li> <p>Instruct all your local Bazel invocations to use that cache:</p> ~/.bazelrc<pre><code>build --remote_cache=grpc://&lt;ip&gt;:&lt;port&gt;\n</code></pre> </li> </ol>"},{"location":"setup/remote_execution/#personal-remote-cache","title":"Personal remote cache","text":"<p>If you find yourself running out of disk space, you can move your personal cache to a different machine such as a cloud runner. Since you now access the remote cache via the internet this setup requires some form of authentication:</p> <p></p> ~/.bazelrc<pre><code>build --remote_cache=grpcs://&lt;remote_cache&gt;\n\n# Authenticate as instructed by your remote cache provider. For instance\nbuild --remote_header=...\n</code></pre>"},{"location":"setup/remote_execution/#trusted-remote-cache","title":"Trusted remote cache","text":"<p>With <code>rules_ll</code> you can share the remote cache among different machines of the same system architecture and still achieve virtually perfect cache hit rate. You can set this up like the personal remote cache, just shared by different users:</p> <p></p> ~/.bazelrc<pre><code>build --remote_cache=grpcs://&lt;trusted_remote_cache&gt;\n\n# Authenticate as instructed by your remote cache provider.\nbuild --some_authentication_flags\n</code></pre>"},{"location":"setup/remote_execution/#open-remote-execution","title":"Open remote execution","text":"<p>This setup lets your contributors use cache artifacts from CI runs locally. This way contributors can fetch prebuilt artifacts from upstream without having to rebuild the entire project themselves. This works because the toolchain for local execution reproduces the remote execution environments.</p> <p>A setup like this lets your contributors use projects the size of LLVM from upstream in 2 minutes from a clean cache on a laptop. They can download prebuilt cache artifacts from the CI pipeline instead of having to rebuild the project themselves.</p> <p></p> <ol> <li><code>user_1</code> merges a PR.</li> <li>The CI pipeline triggers the build and tests, using a remote executor.</li> <li>The CI runner has write access to the cache so that the remote executor can    populate the cache during the build.</li> <li>Contributors with read access to the cache can now fetch the latest artifacts    as part of their build.</li> </ol> ci_runner/.bazelrc<pre><code>build --remote_cache=grpcs://&lt;open_remote_cache&gt;\nbuild --remote_executor=grpcs://&lt;remote_executor&gt;\nbuild --some_authentication_flag\n</code></pre> contributor/.bazelrc<pre><code>build --remote_cache=grpcs://&lt;open_remote_cache&gt;\nbuild --some_authentication_flag_only_read_access\nbuild --noremote_upload_local_results\n</code></pre>"},{"location":"setup/setup/","title":"Setup","text":""},{"location":"setup/setup/#setup","title":"Setup","text":"<p>This guide explains how to set up <code>rules_ll</code>. If you just plan on using the <code>rules_cc</code> compatible remote execution setup you still need to follow this guide.</p> System requirements <p><code>rules_ll</code> makes heavy use of upstream dependencies. Staying upstream sometimes means that backwards-incompatible changes make it into <code>rules_ll</code> faster than into other toolchains. Because of this <code>rules_ll</code> won't work on some older systems.</p> <p>Prerequisites:</p> <ul> <li>An <code>x86_64</code> processor. You can verify this with <code>uname -a</code>.</li> <li>A Linux kernel with 64-bit support. You can verify this with   <code>getconf LONG_BIT</code>.</li> <li>As a rough guideline, at least 10 GB of disk space for fetched   dependencies and build artifacts. Using all toolchains, debug and   optimization modes might require more than 30 GB of disk space. If the   build cache gets too large over time you can reset it using the   <code>bazel clean</code> and <code>bazel clean --expunge</code> commands.</li> <li>As a rough guideline, at least 1 GB of Memory per CPU core. The <code>nproc</code>   command prints the number of CPU cores available to your environment.</li> </ul> <ol> <li> <p>Install the nix package manager and enable    flakes.</p> </li> <li> <p>Create a <code>rules_ll</code> compatible workspace. To keep the development shell in    sync with the <code>rules_ll</code> Bazel module, pin the flake to a specific version:</p> <pre><code>git init\nnix flake init -t github:eomii/rules_ll/&lt;version&gt;\n</code></pre> <p>The default toolchains include C++ and HIP for AMDGPU. If you want to target NVPTX devices (Nvidia GPUs), make sure to read the CUDA license and set <code>unfree = true</code> in <code>flake.nix</code>.</p> <p>See tags to find the most recent version.</p> </li> <li> <p>Enter a <code>rules_ll</code> development shell:</p> <pre><code>nix develop\n</code></pre> </li> <li> <p>Consider setting up at least a local remote cache as described in the remote    execution guide.</p> </li> </ol> <p>See <code>rules_ll/examples</code> for examples. The Guides explain more advanced features of <code>rules_ll</code> such as Clang-Tidy, C++ modules, and heterogeneous programming.</p>"}]}